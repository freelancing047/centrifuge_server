/*
 * @(#) TaskContext.java,  23.03.2010
 *
 */
package csi.server.task.api;

import java.lang.reflect.Method;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.servlet.http.HttpServletResponse;

import csi.security.Authorization;
import csi.security.CsiSecurityManager;
import csi.server.common.codec.Codec;
import csi.server.task.core.TaskGroupId;
import csi.server.util.jogformer.Jogformer;

/**
 * Holds the entire context of one Task Request.
 *
 * @author <a href="mailto:iulian.boanca@lpro.leverpointinc.com">Iulian
 *         Boanca</a>
 *
 */
public class TaskContext {

    /**
     * The ID of the Task that needs to be performed (Generated by the client).
     * Unique per user session.
     */
    private String taskId;

    /**
     * group id of the task. Multiple tasks will be grouped based on this group id.
     */
    private TaskGroupId taskGroupId;

    /** The type of client who built this instance */
    private String type;

    /** Request context path */
    private String contextPath;

    private String requestURL;

    /** The AbstractService's method that needs to be invoked */
    private Method method;

    private String methodName;

    private Object[] methodArgs = null;

    /** The Security Token for this operation */
    private Authorization securityToken;

    private String clientId;

    private TaskSession taskSession;

    private boolean adminTask;

    private AtomicBoolean cancelRequested = new AtomicBoolean(false);

    /** The Date of the Cancel operation invocation */
    private LocalDateTime cancelDate;

    /** The result of this task execution */
    private TaskStatus status;

    /** The Task needed parameters */
    private Map<String, Object> parameters;

    /** The value of the Service Path (e.g.: /a/b/c) */
    private String servicePath;

    /** Codec to use when marshalling/unmarshalling */
    private Codec codec;

    /** Current executing Thread that owns this TaskContext */
    private Thread executingThread;

    /** Flag indicating if the current invoked service method can be forced interrupted */
    private boolean interruptable;

    /** Flag indicating if this tasks should be executed synchronously */
    private boolean synchronous = false;

    private String sessionId;

    private HttpServletResponse synchronousHttpResponse;

    /** Holds the number of retries if response generated by this task could not be send */
    private int retryCount = 0;

    /** Service request type, source from GWT RPC or Flex/Comet/XStream */
    private boolean gwtService = false;

    /** Used to enforce singular sessions on a dataview */
    private String resourceuuid = null;

    private Object serviceClass;

    private Jogformer postSessionJogformer;
    private Jogformer preSessionJogformer;

    private String clientIP;
    private String remoteUser;
    private String executionPoolId;

    private boolean conflict = false;

    public TaskContext(String clientId, String taskId, TaskGroupId taskGroupId, TaskSession session) {
        this.securityToken = CsiSecurityManager.getAuthorization();
        this.clientId = clientId;
        this.taskId = taskId;
        this.taskGroupId = taskGroupId;
        this.sessionId = session.getId();
        this.taskSession = session;
        this.status = new TaskStatus(clientId, taskId, session.getId());
    }

    public Object getServiceClass() {
        return serviceClass;
    }

    public void setServiceClass(Object serviceClass) {
        this.serviceClass = serviceClass;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getContextPath() {
        return contextPath;
    }

    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;
    }

    public String getRequestURL() {
        return requestURL;
    }

    public void setRequestURL(String requestURL) {
        this.requestURL = requestURL;
    }

    public Method getMethod() {
        return method;
    }

    public void setMethod(Method method) {
        this.method = method;
        if (method != null) {
            this.methodName = method.getName();
        }
    }

    public Object[] getMethodArgs() {
        return methodArgs;
    }

    public void setMethodArgs(Object[] methodArgs) {
        this.methodArgs = methodArgs;
    }

    public Authorization getSecurityToken() {
        return securityToken;
    }

    public String getSessionId() {
        return sessionId;
    }

    public TaskSession getTaskSession() {
        return taskSession;
    }

    public String getTaskId() {
        return taskId;
    }

    public void setTaskId(String taskId) {
        this.taskId = taskId;
    }

    public TaskGroupId getTaskGroupId() {
        return taskGroupId;
    }

    public void setTaskGroupId(TaskGroupId taskGroupId) {
        this.taskGroupId = taskGroupId;
    }

    public void setServicePath(String servicePath) {
        this.servicePath = servicePath;
    }

    public String getServicePath() {
        return servicePath;
    }

    public TaskStatus getStatus() {
        return status;
    }

    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }

    public Map<String, Object> getParameters() {
        if (parameters == null) {
            parameters = new HashMap<String, Object>();
        }
        return parameters;
    }

    public int getRetryCount() {
        return retryCount;
    }

    public void setRetryCount(int retryCount) {
        this.retryCount = retryCount;
    }

    @Override
    public String toString() {
       return new StringBuilder()
                        .append("TaskContext {")
                        .append("\n clientId=").append(clientId)
                        .append("\n, taskId=").append(taskId)
                        .append("\n, taskGroupId").append(taskGroupId.toString())
                        .append("\n, servicePath=").append(servicePath)
                        .append("\n, methodName=").append(methodName)
                        .append("\n, status=").append(status).append("\n}")
                        .toString();
    }

    public void cancel() {
        cancelDate = LocalDateTime.now();
        cancelRequested.set(true);
    }

    public boolean isCancelled() {
        return cancelRequested.get();
    }

    public Codec getCodec() {
        return codec;
    }

    public void setCodec(Codec codec) {
        this.codec = codec;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + ((taskId == null) ? 0 : taskId.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final TaskContext other = (TaskContext) obj;
        if (taskId == null) {
            if (other.taskId != null) {
                return false;
            }
        } else if (!taskId.equals(other.taskId)) {
            return false;
        }
        return true;
    }

    public String getClientId() {
        return clientId;
    }

    public void setExecutingThread(Thread t) {
        this.executingThread = t;
    }

    public Thread getExecutingThread() {
        return executingThread;
    }

    public LocalDateTime getCancelDate() {
        return cancelDate;
    }

    public void setInterruptable(boolean interruptable) {
        this.interruptable = interruptable;
    }

    public boolean isInterruptable() {
        return interruptable;
    }

    public void setSynchronous(boolean b) {
        this.synchronous = b;
    }

    public boolean isSynchronous() {
        return this.synchronous;
    }

    public boolean isAdminTask() {
        return adminTask;
    }

    public void setAdminTask(boolean adminTask) {
        this.adminTask = adminTask;
    }

    public String getMethodName() {
        return this.methodName;
    }

    public void clearTaskSession() {
        taskSession = null;
    }

    public void setSynchronousHttpResponse(HttpServletResponse resp) {
        this.synchronousHttpResponse = resp;
    }

    public HttpServletResponse getSynchronousHttpResponse() {
        return synchronousHttpResponse;
    }

    public boolean isGwtService() {
        return gwtService;
    }

    public void setGwtService(boolean gwtService) {
        this.gwtService = gwtService;
    }

    public Jogformer getPostSessionJogformer() {
        return postSessionJogformer;
    }

    public void setPostSessionJogformer(Jogformer postSessionJogformer) {
        this.postSessionJogformer = postSessionJogformer;
    }

    public Jogformer getPreSessionJogformer() {
        return preSessionJogformer;
    }

    public void setPreSessionJogformer(Jogformer preSessionJogformer) {
        this.preSessionJogformer = preSessionJogformer;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public void setClientIP(String clientIpIn) {
        clientIP = clientIpIn;
    }

    public String getClientIP() {
        return clientIP;
    }

    public void setRemoteUser(String remoteUserIn) {
        remoteUser = remoteUserIn;
    }

    public String getRemoteUser() {
        return remoteUser;
    }

    public void setExecutionPoolId(String executionPoolId) {
        this.executionPoolId = executionPoolId;
    }

    public String getExecutionPoolId() {
        return executionPoolId;
    }

    public void setResourceUuid(String resourceUuid) {
        this.resourceuuid = resourceUuid;
    }

    public String getResourceUuid() {
        return this.resourceuuid;
    }

    public void conflict() {
        this.conflict  = true;
    }

    public boolean isConflict() {
        return this.conflict;
    }
}
